---
title: Tools
description: Enable agents to perform actions beyond text generation with tools.
---

<h1 className="mt-4 text-3xl font-medium">
  <span className="text-primary">Tools</span>
</h1>
<h3 className="-mt-7 text-lg font-normal text-muted-foreground">
  Enable agents to perform actions beyond text generation with tools.
</h3>

Tools are actions that agents can perform to interact with the real world. They allow agents to go beyond text generation by enabling operations such as querying databases, calling APIs, performing calculations, reading files, or executing any Python function you define.

Think of tools as the **hands and eyes** of your agent, while the model provides the reasoning **(the brain)**. Tools give the agent the ability to actually act and produce real results. 

When you create an **<u>[Agent](/docs/agents)</u>**, you pass in a list of available **<u>[Tools](/docs/tools)</u>**, and during execution the agent decides whether a tool is needed and invokes it automatically based on the modelâ€™s response.

## Creating a Tool

Use `create_tool()` to wrap a Python function into a tool that an agent can call. Every tool must define a `name`, `description`, `input_parameters`, and a `call_function`. The `call_function` is the underlying Python function that will be executed when the agent invokes the tool.

Below is a simple example tool that converts Celsius to Fahrenheit:

```python
from peargent import create_tool

def celsius_to_fahrenheit(c: float):
    return (c * 9/5) + 32

temperature_tool = create_tool(
    name="CelsiusToFahrenheit",
    description="Convert Celsius temperature to Fahrenheit",
    call_function=celsius_to_fahrenheit,
    input_parameters={"c": float}, # Important 
    output_schema=float
)
```
## Input Parameters Matter

The `input_parameters` serve two critical purposes:

1. **Type Validation** - Peargent validates that the LLM provides the correct types before executing your function, preventing runtime errors
2. **LLM Guidance** - The parameter types help the LLM understand what arguments to provide when calling the tool

## Using Tools with Agents

Tools can be passed to an agent during creation. The agent will automatically decide when a tool is needed and call it as part of its reasoning process.

```python
from peargent import create_agent
from peargent.models import openai

agent = create_agent(
    name="UtilityAgent",
    description="Handles multiple utility tasks",
    persona="You are a helpful assistant.",
    model=openai("gpt-5"),
    tools=[ # You can pass one or multiple tools here
      temperature_tool, 
      count_words_tool, 
      summary_tool] 
)

response = agent.run("Convert 25 degrees Celsius to Fahrenheit.")
# Agent automatically calls the tool and uses the result
```

## Parameters

| Parameter | Type | Description | Required |
| :--- | :--- | :--- | :--- |
| `name` | `str` | Tool identifier | Yes |
| `description` | `str` | What the tool does (helps LLM decide when to use it) | Yes |
| `input_parameters` | `dict[str, type]` | Parameter names and types (e.g., `{"city": str}`) | Yes |
| `call_function` | `Callable` | The Python function to execute | Yes |
| `timeout` | `float \| None` | Max execution time in seconds (default: `None`) | No |
| `max_retries` | `int` | Retry attempts on failure (default: `0`) | No |
| `retry_delay` | `float` | Initial delay between retries in seconds (default: `1.0`) | No |
| `retry_backoff` | `bool` | Use exponential backoff (default: `True`) | No |
| `on_error` | `str` | Error handling: `"raise"`, `"return_error"`, or `"return_none"` (default: `"raise"`) | No |
| `output_schema` | `Type[BaseModel]` | Pydantic model for output validation | No |

 For advanced configuration like `timeouts`, `retries`, `error-handling`, and `output validation`,
 see the **<u>Advanced Features</u>**.
